// Keycloak OAuth2 æ¤œè¨¼ã‚¹ã‚¯ãƒªãƒ—ãƒˆ
// MoonBit ã® OAuth2 å®Ÿè£…ã‚’ä½¿ç”¨ã—ã¦ Keycloak ã®å„ãƒ•ãƒ­ãƒ¼ã‚’ãƒ†ã‚¹ãƒˆã—ã¾ã™

///|
/// ç’°å¢ƒå¤‰æ•°ã‹ã‚‰è¨­å®šã‚’èª­ã¿è¾¼ã‚€
struct Config {
  realm : String
  base_url : String
  token_endpoint : String
  auth_endpoint : String
  client_id : String
  client_secret : String
  test_username : String
  test_password : String
}

///|
/// ç’°å¢ƒå¤‰æ•°ã¾ãŸã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‹ã‚‰è¨­å®šã‚’æ§‹ç¯‰
fn Config::from_env() -> Config {
  let realm = match @sys.get_env_var("KEYCLOAK_REALM") {
    Some(v) => v
    None => "test-realm"
  }
  let base_url = match @sys.get_env_var("KEYCLOAK_BASE_URL") {
    Some(v) => v
    None => "http://localhost:8080/realms/\{realm}"
  }
  let token_endpoint = match @sys.get_env_var("TOKEN_ENDPOINT") {
    Some(v) => v
    None => "\{base_url}/protocol/openid-connect/token"
  }
  let auth_endpoint = "\{base_url}/protocol/openid-connect/auth"
  let client_id = match @sys.get_env_var("CLIENT_ID") {
    Some(v) => v
    None => "test-client"
  }
  let client_secret = match @sys.get_env_var("CLIENT_SECRET") {
    Some(v) => v
    None => ""
  }
  let test_username = match @sys.get_env_var("TEST_USERNAME") {
    Some(v) => v
    None => "testuser"
  }
  let test_password = match @sys.get_env_var("TEST_PASSWORD") {
    Some(v) => v
    None => "testpass123"
  }

  Config::{
    realm,
    base_url,
    token_endpoint,
    auth_endpoint,
    client_id,
    client_secret,
    test_username,
    test_password,
  }
}

///|
/// ãƒ†ã‚¹ãƒˆçµæœã‚’è¡¨ç¤º
fn print_result(test_name : String, success : Bool, message : String) -> Unit {
  let status = if success { "âœ“ æˆåŠŸ" } else { "âœ— å¤±æ•—" }
  let color = if success { "\u{1b}[32m" } else { "\u{1b}[31m" }
  let reset = "\u{1b}[0m"
  println("\{color}[\{status}]\{reset} \{test_name}")
  if message != "" {
    println("  \{message}")
  }
}

///|
/// ã‚»ãƒ‘ãƒ¬ãƒ¼ã‚¿ãƒ¼ã‚’è¡¨ç¤º
fn print_separator(title : String) -> Unit {
  println("")
  println("============================================================")
  println(title)
  println("============================================================")
}

///|
/// Client Credentials Flow ã®ãƒ†ã‚¹ãƒˆ
async fn test_client_credentials(config : Config) -> Unit {
  print_separator("Test 1: Client Credentials Flow")
  println("Token Endpoint: \{config.token_endpoint}")
  println("Client ID: \{config.client_id}")
  println("")

  // OAuth2 å‹ã‚’æ§‹ç¯‰
  let token_url = @oauth2.TokenUrl::new(config.token_endpoint)
  let client_id = @oauth2.ClientId::new(config.client_id)
  let client_secret = @oauth2.ClientSecret::new(config.client_secret)
  let scopes = [@oauth2.Scope::new("openid")]

  // ClientCredentialsRequest ã‚’ä½œæˆ
  let request = @oauth2.ClientCredentialsRequest::new(
    token_url,
    client_id,
    client_secret,
    scopes,
  )

  println("ãƒªã‚¯ã‚¨ã‚¹ãƒˆé€ä¿¡ä¸­...")

  // HTTP ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚’ä½œæˆã—ã¦å®Ÿè¡Œ
  let http_client = @oauth2.OAuth2HttpClient::new()
  let result = request.execute(http_client)

  match result {
    Ok(response) => {
      // æˆåŠŸãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®æ¤œè¨¼
      print_result("ãƒˆãƒ¼ã‚¯ãƒ³å–å¾—", true, "")
      println("")
      println("ğŸ“‹ ãƒˆãƒ¼ã‚¯ãƒ³æƒ…å ±:")
      println("  Token Type: \{response.token_type()}")

      match response.expires_in() {
        Some(expires) => println("  Expires In: \{expires}ç§’")
        None => println("  Expires In: æŒ‡å®šãªã—")
      }

      let token_str = response.access_token().to_string()
      let token_preview = if token_str.length() > 50 {
        token_str[0:50].to_string() + "..."
      } else {
        token_str
      }
      println("  Access Token (å…ˆé ­50æ–‡å­—): \{token_preview}")

      match response.scope() {
        Some(scope) => println("  Scope: \{scope}")
        None => ()
      }

      // ãƒˆãƒ¼ã‚¯ãƒ³ãŒ JWT å½¢å¼ã‹ãƒã‚§ãƒƒã‚¯
      let is_jwt = token_str.contains(".")
      print_result("JWT å½¢å¼", is_jwt, "")

      // æœ‰åŠ¹æœŸé™ã®ãƒã‚§ãƒƒã‚¯
      match response.expires_in() {
        Some(expires) => {
          let valid_expiry = expires > 0 && expires <= 3600
          print_result("æœ‰åŠ¹æœŸé™", valid_expiry, "expires_in=\{expires}ç§’")
        }
        None => print_result("æœ‰åŠ¹æœŸé™", false, "æœ‰åŠ¹æœŸé™ãŒæŒ‡å®šã•ã‚Œã¦ã„ã¾ã›ã‚“")
      }
    }
    Err(error) => {
      print_result("Client Credentials Flow", false, error.message())
    }
  }
}

///|
/// Password Grant Flow ã®ãƒ†ã‚¹ãƒˆ
async fn test_password_grant(config : Config) -> Unit {
  print_separator("Test 2: Password Grant Flow")
  println("Token Endpoint: \{config.token_endpoint}")
  println("Client ID: \{config.client_id}")
  println("Username: \{config.test_username}")
  println("")

  // OAuth2 å‹ã‚’æ§‹ç¯‰
  let token_url = @oauth2.TokenUrl::new(config.token_endpoint)
  let client_id = @oauth2.ClientId::new(config.client_id)
  let client_secret = @oauth2.ClientSecret::new(config.client_secret)
  let scopes = [
    @oauth2.Scope::new("openid"),
    @oauth2.Scope::new("profile"),
    @oauth2.Scope::new("email"),
  ]

  // PasswordRequest ã‚’ä½œæˆ
  let request = @oauth2.PasswordRequest::new(
    token_url,
    client_id,
    Some(client_secret),
    config.test_username,
    config.test_password,
    scopes,
  )

  println("ãƒªã‚¯ã‚¨ã‚¹ãƒˆé€ä¿¡ä¸­...")

  // HTTP ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚’ä½œæˆã—ã¦å®Ÿè¡Œ
  let http_client = @oauth2.OAuth2HttpClient::new()
  let result = request.execute(http_client)

  match result {
    Ok(response) => {
      // æˆåŠŸãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®æ¤œè¨¼
      print_result("ãƒˆãƒ¼ã‚¯ãƒ³å–å¾—", true, "")
      println("")
      println("ğŸ“‹ ãƒˆãƒ¼ã‚¯ãƒ³æƒ…å ±:")
      println("  Token Type: \{response.token_type()}")

      match response.expires_in() {
        Some(expires) => println("  Expires In: \{expires}ç§’")
        None => println("  Expires In: æŒ‡å®šãªã—")
      }

      let token_str = response.access_token().to_string()
      let token_preview = if token_str.length() > 50 {
        token_str[0:50].to_string() + "..."
      } else {
        token_str
      }
      println("  Access Token (å…ˆé ­50æ–‡å­—): \{token_preview}")

      match response.refresh_token() {
        Some(rt) => {
          let rt_str = rt.to_string()
          let rt_preview = if rt_str.length() > 50 {
            rt_str[0:50].to_string() + "..."
          } else {
            rt_str
          }
          println("  Refresh Token (å…ˆé ­50æ–‡å­—): \{rt_preview}")
        }
        None => ()
      }

      match response.scope() {
        Some(scope) => println("  Scope: \{scope}")
        None => ()
      }

      // å„ãƒˆãƒ¼ã‚¯ãƒ³ã®æ¤œè¨¼
      print_result("Access Token å–å¾—", true, "")
      let has_refresh_token = match response.refresh_token() {
        Some(_) => true
        None => false
      }
      print_result("Refresh Token å–å¾—", has_refresh_token, "")

      // ãƒˆãƒ¼ã‚¯ãƒ³ãŒ JWT å½¢å¼ã‹ãƒã‚§ãƒƒã‚¯
      let is_jwt = token_str.contains(".")
      print_result("JWT å½¢å¼", is_jwt, "")

      // UserInfo ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã§ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚’å–å¾—
      println("")
      println("ğŸ“‹ UserInfo ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã§ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚’å–å¾—:")
      let userinfo_url = "\{config.base_url}/protocol/openid-connect/userinfo"
      println("  URL: \{userinfo_url}")

      let headers : Map[String, String] = {
        "Authorization": "Bearer \{token_str}",
        "Accept": "application/json",
      }

      let (resp, body) = @http.get(userinfo_url, headers~)
      if resp.code == 200 {
        print_result("UserInfo å–å¾—", true, "")
        println("")
        println("  ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±:")
        let body_str = body.text()
        println("  \{body_str}")

        // JSONã‹ã‚‰åŸºæœ¬æƒ…å ±ã‚’æŠ½å‡ºï¼ˆç°¡æ˜“ãƒ‘ãƒ¼ã‚¹ï¼‰
        if body_str.contains("\"sub\"") {
          print_result("sub (ãƒ¦ãƒ¼ã‚¶ãƒ¼ID) å­˜åœ¨", true, "")
        }
        if body_str.contains("\"preferred_username\"") {
          print_result("preferred_username å­˜åœ¨", true, "")
        }
        if body_str.contains("\"email\"") {
          print_result("email å­˜åœ¨", true, "")
        }
      } else {
        print_result("UserInfo å–å¾—", false, "HTTP \{resp.code}")
      }
    }
    Err(error) => {
      print_result("Password Grant Flow", false, error.message())
    }
  }
}

///|
/// Authorization Code Flow ã®æº–å‚™ãƒ†ã‚¹ãƒˆï¼ˆèªå¯ URL ç”Ÿæˆï¼‰
fn test_authorization_code_preparation(config : Config) -> Unit {
  print_separator("Test 3: Authorization Code Flow (æº–å‚™)")
  println("Authorization Endpoint: \{config.auth_endpoint}")
  println("Client ID: \{config.client_id}")
  println("")

  // OAuth2 å‹ã‚’æ§‹ç¯‰
  let auth_url = @oauth2.AuthUrl::new(config.auth_endpoint)
  let client_id = @oauth2.ClientId::new(config.client_id)
  let redirect_uri = @oauth2.RedirectUrl::new("http://localhost:3000/callback")
  let scopes = [
    @oauth2.Scope::new("openid"),
    @oauth2.Scope::new("profile"),
    @oauth2.Scope::new("email"),
  ]
  let state = @oauth2.generate_csrf_token()

  // PKCE ã‚’ç”Ÿæˆ
  let pkce_verifier = @oauth2.PkceCodeVerifier::new_random()
  let pkce_challenge = @oauth2.PkceCodeChallenge::from_verifier_s256(pkce_verifier)

  // AuthorizationRequest ã‚’ä½œæˆï¼ˆPKCE ä»˜ãï¼‰
  let request = @oauth2.AuthorizationRequest::new_with_pkce(
    auth_url,
    client_id,
    redirect_uri,
    scopes,
    state,
    pkce_challenge,
  )

  // èªå¯ URL ã‚’æ§‹ç¯‰
  let authorization_url = request.build_authorization_url()

  print_result("èªå¯ URL ç”Ÿæˆ", true, "")
  println("")
  println("ğŸ“‹ ç”Ÿæˆã•ã‚ŒãŸèªå¯ URL:")
  println("\{authorization_url}")
  println("")
  println("ğŸŒ ãƒ–ãƒ©ã‚¦ã‚¶ã§ã®å‹•ä½œç¢ºèªæ‰‹é †:")
  println("  1. ä¸Šè¨˜ URL ã‚’ãƒ–ãƒ©ã‚¦ã‚¶ã§é–‹ã")
  println("  2. Keycloak ãƒ­ã‚°ã‚¤ãƒ³ç”»é¢ãŒè¡¨ç¤ºã•ã‚Œã‚‹")
  println("  3. \{config.test_username} / \{config.test_password} ã§ãƒ­ã‚°ã‚¤ãƒ³")
  println("  4. ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆ URI ã«ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã•ã‚Œã‚‹")
  println("  5. URL ã‹ã‚‰èªå¯ã‚³ãƒ¼ãƒ‰ (code) ã‚’å–å¾—")
  println("")

  // URL ã®æ§‹é€ ãƒã‚§ãƒƒã‚¯
  let has_client_id = authorization_url.contains("client_id=")
  let has_redirect = authorization_url.contains("redirect_uri=")
  let has_scope = authorization_url.contains("scope=")
  let has_state = authorization_url.contains("state=")
  let has_pkce = authorization_url.contains("code_challenge=")

  print_result("client_id ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿", has_client_id, "")
  print_result("redirect_uri ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿", has_redirect, "")
  print_result("scope ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿", has_scope, "")
  print_result("state ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿", has_state, "")
  print_result("PKCE code_challenge", has_pkce, "")
}

///|
/// ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®ãƒ†ã‚¹ãƒˆ
async fn test_error_handling(config : Config) -> Unit {
  print_separator("Test 4: ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°")
  println("ç„¡åŠ¹ãªèªè¨¼æƒ…å ±ã§ã‚¨ãƒ©ãƒ¼ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’æ¤œè¨¼")
  println("")

  // ç„¡åŠ¹ãª Client Secret ã§ãƒ†ã‚¹ãƒˆ
  let token_url = @oauth2.TokenUrl::new(config.token_endpoint)
  let client_id = @oauth2.ClientId::new(config.client_id)
  let invalid_secret = @oauth2.ClientSecret::new("invalid-secret")
  let scopes = [@oauth2.Scope::new("openid")]

  let request = @oauth2.ClientCredentialsRequest::new(
    token_url,
    client_id,
    invalid_secret,
    scopes,
  )

  let http_client = @oauth2.OAuth2HttpClient::new()
  let result = request.execute(http_client)

  match result {
    Ok(_) => print_result("ç„¡åŠ¹ãª Client Secret", false, "ã‚¨ãƒ©ãƒ¼ãŒè¿”ã•ã‚Œã‚‹ã¹ã")
    Err(error) => {
      let msg = error.message()
      let msg_lower = msg.to_string().to_lower()
      // InvalidClient ã¾ãŸã¯ Unauthorized ã‚¨ãƒ©ãƒ¼ã‚’æœŸå¾…
      if msg_lower.contains("invalid_client") || msg_lower.contains("unauthorized") {
        print_result("ç„¡åŠ¹ãª Client Secret", true, "æ­£ã—ãã‚¨ãƒ©ãƒ¼ã‚’è¿”ã—ã¾ã—ãŸ")
      } else {
        print_result("ç„¡åŠ¹ãª Client Secret", false, "äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼: \{msg}")
      }
    }
  }

  // ç„¡åŠ¹ãªãƒ¦ãƒ¼ã‚¶ãƒ¼èªè¨¼æƒ…å ±ã§ãƒ†ã‚¹ãƒˆ
  let client_secret = @oauth2.ClientSecret::new(config.client_secret)

  let password_request = @oauth2.PasswordRequest::new(
    token_url,
    client_id,
    Some(client_secret),
    config.test_username,
    "wrong-password",
    scopes,
  )

  let http_client2 = @oauth2.OAuth2HttpClient::new()
  let result2 = password_request.execute(http_client2)

  match result2 {
    Ok(_) => print_result("ç„¡åŠ¹ãªãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰", false, "ã‚¨ãƒ©ãƒ¼ãŒè¿”ã•ã‚Œã‚‹ã¹ã")
    Err(error) => {
      let msg = error.message()
      let msg_lower = msg.to_string().to_lower()
      // InvalidGrant ã‚¨ãƒ©ãƒ¼ã‚’æœŸå¾…
      if msg_lower.contains("invalid_grant") || msg_lower.contains("invalid user") {
        print_result("ç„¡åŠ¹ãªãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰", true, "æ­£ã—ãã‚¨ãƒ©ãƒ¼ã‚’è¿”ã—ã¾ã—ãŸ")
      } else {
        print_result("ç„¡åŠ¹ãªãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰", false, "äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼: \{msg}")
      }
    }
  }
}

///|
/// ãƒ¡ã‚¤ãƒ³ã‚¨ãƒ³ãƒˆãƒªãƒã‚¤ãƒ³ãƒˆ
async fn main {
  println("\u{1b}[1;36m============================================================\u{1b}[0m")
  println("\u{1b}[1;36mKeycloak OAuth2 æ¤œè¨¼ã‚¹ã‚¯ãƒªãƒ—ãƒˆ (MoonBit)\u{1b}[0m")
  println("\u{1b}[1;36m============================================================\u{1b}[0m")
  println("")

  // è¨­å®šã‚’èª­ã¿è¾¼ã¿
  let config = Config::from_env()

  // Client Secret ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
  if config.client_secret == "" {
    println("\u{1b}[31mâœ— ã‚¨ãƒ©ãƒ¼: CLIENT_SECRET ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“\u{1b}[0m")
    println("")
    println("ä»¥ä¸‹ã®ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„:")
    println("  export CLIENT_SECRET=\"your-client-secret-here\"")
    println("")
    println("Client Secret ã¯ä»¥ä¸‹ã®æ–¹æ³•ã§å–å¾—ã§ãã¾ã™:")
    println("  1. ./scripts/setup_keycloak.sh ã‚’å®Ÿè¡Œ")
    println("  2. ã¾ãŸã¯ Keycloak ç®¡ç†ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã‹ã‚‰å–å¾—")
    println("     http://localhost:8080/admin")
    println("     â†’ Clients â†’ test-client â†’ Credentials ã‚¿ãƒ–")
    println("")
    return
  }

  let secret_preview = if config.client_secret.length() > 10 {
    config.client_secret[0:10].to_string() + "..."
  } else {
    "***"
  }

  println("ğŸ“‹ è¨­å®š:")
  println("  Realm: \{config.realm}")
  println("  Base URL: \{config.base_url}")
  println("  Token Endpoint: \{config.token_endpoint}")
  println("  Client ID: \{config.client_id}")
  println("  Client Secret: \{secret_preview}")
  println("  Test User: \{config.test_username}")
  println("")

  // å„ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œ
  test_client_credentials(config)
  test_password_grant(config)
  test_authorization_code_preparation(config)
  test_error_handling(config)

  // ã‚µãƒãƒªãƒ¼
  print_separator("ãƒ†ã‚¹ãƒˆå®Œäº†")
  println("")
  println("âœ“ MoonBit OAuth2 å®Ÿè£…ã§ Keycloak ã®å‹•ä½œã‚’æ¤œè¨¼ã—ã¾ã—ãŸ")
  println("")
  println("ğŸ“– è©³ç´°ãªæ‰‹é †ã¯ docs/testing/keycloak_verification_guide.md ã‚’å‚ç…§")
  println("")
}
