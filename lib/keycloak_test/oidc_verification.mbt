// Keycloak OIDC æ¤œè¨¼ã‚¹ã‚¯ãƒªãƒ—ãƒˆ
// MoonBit ã® OIDC å®Ÿè£…ã‚’ä½¿ç”¨ã—ã¦ Keycloak ã® OIDC æ©Ÿèƒ½ã‚’ãƒ†ã‚¹ãƒˆã—ã¾ã™

///|
/// ç’°å¢ƒå¤‰æ•°ã‹ã‚‰è¨­å®šã‚’èª­ã¿è¾¼ã‚€
struct OidcConfig {
  realm : String
  base_url : String
  token_endpoint : String
  auth_endpoint : String
  userinfo_endpoint : String
  client_id : String
  client_secret : String
  test_username : String
  test_password : String
}

///|
/// ç’°å¢ƒå¤‰æ•°ã¾ãŸã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‹ã‚‰è¨­å®šã‚’æ§‹ç¯‰
fn OidcConfig::from_env() -> OidcConfig {
  let realm = match @sys.get_env_var("KEYCLOAK_REALM") {
    Some(v) => v
    None => "test-realm"
  }
  let base_url = match @sys.get_env_var("KEYCLOAK_BASE_URL") {
    Some(v) => v
    None => "http://localhost:8080/realms/\{realm}"
  }
  let token_endpoint = match @sys.get_env_var("TOKEN_ENDPOINT") {
    Some(v) => v
    None => "\{base_url}/protocol/openid-connect/token"
  }
  let auth_endpoint = "\{base_url}/protocol/openid-connect/auth"
  let userinfo_endpoint = "\{base_url}/protocol/openid-connect/userinfo"
  let client_id = match @sys.get_env_var("CLIENT_ID") {
    Some(v) => v
    None => "test-client"
  }
  let client_secret = match @sys.get_env_var("CLIENT_SECRET") {
    Some(v) => v
    None => ""
  }
  let test_username = match @sys.get_env_var("TEST_USERNAME") {
    Some(v) => v
    None => "testuser"
  }
  let test_password = match @sys.get_env_var("TEST_PASSWORD") {
    Some(v) => v
    None => "testpass123"
  }

  OidcConfig::{
    realm,
    base_url,
    token_endpoint,
    auth_endpoint,
    userinfo_endpoint,
    client_id,
    client_secret,
    test_username,
    test_password,
  }
}

///|
/// ãƒ†ã‚¹ãƒˆçµæœã‚’è¡¨ç¤º
fn print_test_result(
  test_name : String,
  success : Bool,
  message : String
) -> Unit {
  let status = if success { "âœ“ æˆåŠŸ" } else { "âœ— å¤±æ•—" }
  let color = if success { "\u{1b}[32m" } else { "\u{1b}[31m" }
  let reset = "\u{1b}[0m"
  println("\{color}[\{status}]\{reset} \{test_name}")
  if message != "" {
    println("  \{message}")
  }
}

///|
/// ã‚»ãƒ‘ãƒ¬ãƒ¼ã‚¿ãƒ¼ã‚’è¡¨ç¤º
fn print_test_separator(title : String) -> Unit {
  println("")
  println("============================================================")
  println(title)
  println("============================================================")
}

///|
/// ID Token å–å¾—ãƒ†ã‚¹ãƒˆï¼ˆPassword Grant Flowï¼‰
async fn test_id_token_acquisition(config : OidcConfig) -> Unit {
  print_test_separator("Test 1: ID Tokenå–å¾—ï¼ˆPassword Grant Flowï¼‰")
  println("Token Endpoint: \{config.token_endpoint}")
  println("Client ID: \{config.client_id}")
  println("Username: \{config.test_username}")
  println("Scopes: openid, profile, email")
  println("")

  // OAuth2 å‹ã‚’æ§‹ç¯‰
  let token_url = @oauth2.TokenUrl::new(config.token_endpoint)
  let client_id = @oauth2.ClientId::new(config.client_id)
  let client_secret = @oauth2.ClientSecret::new(config.client_secret)
  let scopes = [
    @oauth2.Scope::openid(),
    @oauth2.Scope::profile(),
    @oauth2.Scope::email(),
  ]

  // PasswordRequest ã‚’ä½œæˆ
  let request = @oauth2.PasswordRequest::new(
    token_url,
    client_id,
    Some(client_secret),
    config.test_username,
    config.test_password,
    scopes,
  )

  println("ãƒªã‚¯ã‚¨ã‚¹ãƒˆé€ä¿¡ä¸­...")

  // HTTP ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚’ä½œæˆã—ã¦å®Ÿè¡Œ
  let http_client = @oauth2.OAuth2HttpClient::new()
  let result = request.execute(http_client)

  match result {
    Ok(response) => {
      print_test_result("ãƒˆãƒ¼ã‚¯ãƒ³å–å¾—", true, "")

      // id_token ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ç¢ºèª
      match response.id_token() {
        Some(id_token_str) => {
          print_test_result("id_token ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å­˜åœ¨", true, "")

          // ID Token ã®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è¡¨ç¤º
          let token_preview = if id_token_str.length() > 50 {
            id_token_str[0:50].to_string() + "..."
          } else {
            id_token_str
          }
          println("")
          println("ğŸ“‹ ID Token (å…ˆé ­50æ–‡å­—):")
          println("  \{token_preview}")

          // JWT å½¢å¼ã®ç¢ºèªï¼ˆ3éƒ¨åˆ†ã«åˆ†å‰²ã§ãã‚‹ã‹ï¼‰
          let parts = id_token_str.split(".").collect()
          if parts.length() == 3 {
            print_test_result("JWT å½¢å¼ï¼ˆ3éƒ¨åˆ†æ§‹é€ ï¼‰", true, "")
          } else {
            print_test_result(
              "JWT å½¢å¼ï¼ˆ3éƒ¨åˆ†æ§‹é€ ï¼‰",
              false,
              "éƒ¨åˆ†æ•°: \{parts.length()}",
            )
          }

          // ID Token ã®ãƒ‘ãƒ¼ã‚¹ã‚’è©¦ã¿ã‚‹
          println("")
          println("ğŸ“‹ ID Token ãƒ‘ãƒ¼ã‚¹:")
          match @oidc.IdToken::parse(id_token_str) {
            Ok(id_token) => {
              print_test_result("ID Token ãƒ‘ãƒ¼ã‚¹", true, "")

              // å¿…é ˆã‚¯ãƒ¬ãƒ¼ãƒ ã®ç¢ºèª
              let iss = id_token.issuer()
              let sub = id_token.subject()
              let aud = id_token.audience()
              let exp = id_token.expiration()
              let iat = id_token.issued_at()

              println("")
              println("ğŸ“‹ ID Token ã‚¯ãƒ¬ãƒ¼ãƒ :")
              println("  iss (Issuer): \{iss}")
              println("  sub (Subject): \{sub}")
              println("  aud (Audience): \{aud}")
              println("  exp (Expiration): \{exp}")
              println("  iat (Issued At): \{iat}")

              // ã‚¯ãƒ¬ãƒ¼ãƒ ã®å­˜åœ¨ç¢ºèª
              print_test_result("iss ã‚¯ãƒ¬ãƒ¼ãƒ ", iss != "", "")
              print_test_result("sub ã‚¯ãƒ¬ãƒ¼ãƒ ", sub != "", "")
              print_test_result("aud ã‚¯ãƒ¬ãƒ¼ãƒ ", aud != "", "")
              print_test_result("exp ã‚¯ãƒ¬ãƒ¼ãƒ ", exp > 0L, "")
              print_test_result("iat ã‚¯ãƒ¬ãƒ¼ãƒ ", iat > 0L, "")

              // issuer ã®å¦¥å½“æ€§ç¢ºèªï¼ˆKeycloak ã® base_url ã‚’å«ã‚€ã‹ï¼‰
              let valid_issuer = iss.contains(config.realm)
              print_test_result(
                "Issuer å¦¥å½“æ€§",
                valid_issuer,
                "realm ãŒå«ã¾ã‚Œã‚‹: \{valid_issuer}",
              )

              // audience ã®å¦¥å½“æ€§ç¢ºèªï¼ˆclient_id ã¨ä¸€è‡´ã™ã‚‹ã‹ï¼‰
              let valid_audience = aud == config.client_id
              print_test_result(
                "Audience å¦¥å½“æ€§",
                valid_audience,
                "client_id ã¨ä¸€è‡´: \{valid_audience}",
              )

              // ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚¯ãƒ¬ãƒ¼ãƒ ã®ç¢ºèª
              println("")
              println("ğŸ“‹ ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚¯ãƒ¬ãƒ¼ãƒ :")

              match id_token.email() {
                Some(email) => {
                  println("  email: \{email}")
                  print_test_result("email ã‚¯ãƒ¬ãƒ¼ãƒ ", true, "")
                }
                None => print_test_result("email ã‚¯ãƒ¬ãƒ¼ãƒ ", false, "å­˜åœ¨ã—ã¾ã›ã‚“")
              }

              match id_token.name() {
                Some(name) => {
                  println("  name: \{name}")
                  print_test_result("name ã‚¯ãƒ¬ãƒ¼ãƒ ", true, "")
                }
                None => print_test_result("name ã‚¯ãƒ¬ãƒ¼ãƒ ", false, "å­˜åœ¨ã—ã¾ã›ã‚“")
              }

              match id_token.nonce() {
                Some(nonce) => {
                  println("  nonce: \{nonce}")
                  print_test_result("nonce ã‚¯ãƒ¬ãƒ¼ãƒ ", true, "")
                }
                None => print_test_result("nonce ã‚¯ãƒ¬ãƒ¼ãƒ ", false, "å­˜åœ¨ã—ã¾ã›ã‚“")
              }
            }
            Err(error) =>
              print_test_result("ID Token ãƒ‘ãƒ¼ã‚¹", false, error.message())
          }
        }
        None =>
          print_test_result(
            "id_token ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å­˜åœ¨",
            false,
            "TokenResponse ã« id_token ãŒå«ã¾ã‚Œã¦ã„ã¾ã›ã‚“",
          )
      }
    }
    Err(error) =>
      print_test_result("ãƒˆãƒ¼ã‚¯ãƒ³å–å¾—", false, error.message())
  }
}

///|
/// UserInfo Endpoint ãƒ†ã‚¹ãƒˆ
async fn test_userinfo_endpoint(config : OidcConfig) -> Unit {
  print_test_separator("Test 2: UserInfo Endpoint")
  println("UserInfo Endpoint: \{config.userinfo_endpoint}")
  println("")

  // ã¾ãšãƒˆãƒ¼ã‚¯ãƒ³ã‚’å–å¾—
  println("ğŸ“‹ Access Token å–å¾—ä¸­...")
  let token_url = @oauth2.TokenUrl::new(config.token_endpoint)
  let client_id = @oauth2.ClientId::new(config.client_id)
  let client_secret = @oauth2.ClientSecret::new(config.client_secret)
  let scopes = [
    @oauth2.Scope::openid(),
    @oauth2.Scope::profile(),
    @oauth2.Scope::email(),
  ]

  let request = @oauth2.PasswordRequest::new(
    token_url,
    client_id,
    Some(client_secret),
    config.test_username,
    config.test_password,
    scopes,
  )

  let http_client = @oauth2.OAuth2HttpClient::new()
  let result = request.execute(http_client)

  match result {
    Ok(response) => {
      print_test_result("Access Token å–å¾—", true, "")

      // ID Token ã® sub ã‚’å–å¾—ï¼ˆå¾Œã§æ¯”è¼ƒï¼‰
      let id_token_sub = match response.id_token() {
        Some(id_token_str) =>
          match @oidc.IdToken::parse(id_token_str) {
            Ok(id_token) => Some(id_token.subject())
            Err(_) => None
          }
        None => None
      }

      // UserInfo ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’ä½œæˆ
      println("")
      println("ğŸ“‹ UserInfo ãƒªã‚¯ã‚¨ã‚¹ãƒˆé€ä¿¡ä¸­...")
      let userinfo_url = @oidc.UserInfoUrl::new(config.userinfo_endpoint)
      let userinfo_request = @oidc.UserInfoRequest::new(
        userinfo_url,
        response.access_token(),
      )

      // UserInfo ã‚’å–å¾—
      let http_client2 = @oauth2.OAuth2HttpClient::new()
      let userinfo_result = userinfo_request.execute(http_client2)

      match userinfo_result {
        Ok(userinfo) => {
          print_test_result("UserInfo å–å¾—", true, "")

          println("")
          println("ğŸ“‹ UserInfo:")
          let userinfo_sub = userinfo.sub
          println("  sub: \{userinfo_sub}")

          match userinfo.name {
            Some(name) => println("  name: \{name}")
            None => ()
          }

          match userinfo.email {
            Some(email) => println("  email: \{email}")
            None => ()
          }

          match userinfo.email_verified {
            Some(verified) => println("  email_verified: \{verified}")
            None => ()
          }

          // sub ã®å­˜åœ¨ç¢ºèª
          print_test_result("sub ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰", userinfo_sub != "", "")

          // ID Token ã® sub ã¨ä¸€è‡´ã™ã‚‹ã‹ç¢ºèª
          match id_token_sub {
            Some(token_sub) => {
              let sub_match = userinfo_sub == token_sub
              print_test_result(
                "sub ä¸€è‡´ï¼ˆID Token vs UserInfoï¼‰",
                sub_match,
                "ä¸€è‡´: \{sub_match}",
              )
            }
            None =>
              print_test_result(
                "sub ä¸€è‡´ï¼ˆID Token vs UserInfoï¼‰",
                false,
                "ID Token ãŒå–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸ",
              )
          }

          // ã‚ªãƒ—ã‚·ãƒ§ãƒ³ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ç¢ºèª
          let has_name = match userinfo.name {
            Some(_) => true
            None => false
          }
          print_test_result("name ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰", has_name, "")

          let has_email = match userinfo.email {
            Some(_) => true
            None => false
          }
          print_test_result("email ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰", has_email, "")
        }
        Err(error) =>
          print_test_result("UserInfo å–å¾—", false, error.message())
      }
    }
    Err(error) => print_test_result("Access Token å–å¾—", false, error.message())
  }
}

///|
/// nonce ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ†ã‚¹ãƒˆ
fn test_nonce_parameter(config : OidcConfig) -> Unit {
  print_test_separator("Test 3: nonce ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿")
  println("Authorization Endpoint: \{config.auth_endpoint}")
  println("")

  // nonce ã‚’ç”Ÿæˆ
  let nonce = @oauth2.generate_nonce()
  println("ğŸ“‹ ç”Ÿæˆã•ã‚ŒãŸ nonce:")
  println("  \{nonce}")
  print_test_result("nonce ç”Ÿæˆ", true, "")

  // Authorization URL ã‚’æ§‹ç¯‰ï¼ˆnonce ä»˜ãï¼‰
  let auth_url = @oauth2.AuthUrl::new(config.auth_endpoint)
  let client_id = @oauth2.ClientId::new(config.client_id)
  let redirect_uri = @oauth2.RedirectUrl::new("http://localhost:3000/callback")
  let scopes = [@oauth2.Scope::openid(), @oauth2.Scope::profile()]
  let state = @oauth2.generate_csrf_token()
  let pkce_verifier = @oauth2.PkceCodeVerifier::new_random()
  let pkce_challenge = @oauth2.PkceCodeChallenge::from_verifier_s256(
    pkce_verifier,
  )

  // nonce ã‚’å«ã‚€ Authorization Request ã‚’ä½œæˆ
  let mut request = @oauth2.AuthorizationRequest::new_with_pkce(
    auth_url, client_id, redirect_uri, scopes, state, pkce_challenge,
  )
  request = request.with_nonce(nonce)

  // Authorization URL ã‚’æ§‹ç¯‰
  let authorization_url = request.build_authorization_url()

  println("")
  println("ğŸ“‹ ç”Ÿæˆã•ã‚ŒãŸ Authorization URL:")
  println("\{authorization_url}")
  println("")

  // URL ã« nonce ãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
  let has_nonce = authorization_url.contains("nonce=")
  print_test_result("nonce ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å­˜åœ¨", has_nonce, "")

  // ãã®ä»–ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚‚ç¢ºèª
  let has_client_id = authorization_url.contains("client_id=")
  let has_redirect = authorization_url.contains("redirect_uri=")
  let has_scope = authorization_url.contains("scope=")
  let has_openid = authorization_url.contains("openid")

  print_test_result("client_id ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿", has_client_id, "")
  print_test_result("redirect_uri ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿", has_redirect, "")
  print_test_result("scope ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿", has_scope, "")
  print_test_result("openid ã‚¹ã‚³ãƒ¼ãƒ—", has_openid, "")
}

///|
/// ãƒˆãƒ¼ã‚¯ãƒ³ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°ãƒ†ã‚¹ãƒˆ
async fn test_token_response_helpers(config : OidcConfig) -> Unit {
  print_test_separator("Test 4: TokenResponse ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°")
  println("")

  // ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å–å¾—
  println("ğŸ“‹ ãƒˆãƒ¼ã‚¯ãƒ³å–å¾—ä¸­...")
  let token_url = @oauth2.TokenUrl::new(config.token_endpoint)
  let client_id = @oauth2.ClientId::new(config.client_id)
  let client_secret = @oauth2.ClientSecret::new(config.client_secret)
  let scopes = [@oauth2.Scope::openid()]

  let request = @oauth2.PasswordRequest::new(
    token_url,
    client_id,
    Some(client_secret),
    config.test_username,
    config.test_password,
    scopes,
  )

  let http_client = @oauth2.OAuth2HttpClient::new()
  let result = request.execute(http_client)

  match result {
    Ok(response) => {
      print_test_result("ãƒˆãƒ¼ã‚¯ãƒ³å–å¾—", true, "")

      // parse_id_token_from_response ãƒ†ã‚¹ãƒˆï¼ˆOption ã‚’è¿”ã™ï¼‰
      println("")
      println("ğŸ“‹ parse_id_token_from_response ãƒ†ã‚¹ãƒˆ:")
      match @oidc.parse_id_token_from_response(response) {
        Ok(Some(id_token)) => {
          print_test_result("parse_id_token_from_response", true, "")
          println("  sub: \{id_token.subject()}")
        }
        Ok(None) =>
          print_test_result(
            "parse_id_token_from_response",
            false,
            "id_token ãŒå­˜åœ¨ã—ã¾ã›ã‚“",
          )
        Err(error) =>
          print_test_result(
            "parse_id_token_from_response",
            false,
            error.message(),
          )
      }

      // get_id_token_from_response ãƒ†ã‚¹ãƒˆï¼ˆError ã‚’è¿”ã™ï¼‰
      println("")
      println("ğŸ“‹ get_id_token_from_response ãƒ†ã‚¹ãƒˆ:")
      match @oidc.get_id_token_from_response(response) {
        Ok(id_token) => {
          print_test_result("get_id_token_from_response", true, "")
          println("  sub: \{id_token.subject()}")
        }
        Err(error) =>
          print_test_result(
            "get_id_token_from_response",
            false,
            error.message(),
          )
      }
    }
    Err(error) => print_test_result("ãƒˆãƒ¼ã‚¯ãƒ³å–å¾—", false, error.message())
  }
}

///|
/// ãƒ¡ã‚¤ãƒ³ã‚¨ãƒ³ãƒˆãƒªãƒã‚¤ãƒ³ãƒˆ
async fn run_oidc_verification() -> Unit {
  println(
    "\u{1b}[1;36m============================================================\u{1b}[0m",
  )
  println("\u{1b}[1;36mKeycloak OIDC æ¤œè¨¼ã‚¹ã‚¯ãƒªãƒ—ãƒˆ (MoonBit)\u{1b}[0m")
  println(
    "\u{1b}[1;36m============================================================\u{1b}[0m",
  )
  println("")

  // è¨­å®šã‚’èª­ã¿è¾¼ã¿
  let config = OidcConfig::from_env()

  // Client Secret ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
  if config.client_secret == "" {
    println(
      "\u{1b}[31mâœ— ã‚¨ãƒ©ãƒ¼: CLIENT_SECRET ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“\u{1b}[0m",
    )
    println("")
    println("ä»¥ä¸‹ã®ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„:")
    println("  export CLIENT_SECRET=\"your-client-secret-here\"")
    println("")
    return
  }

  let secret_preview = if config.client_secret.length() > 10 {
    config.client_secret[0:10].to_string() + "..."
  } else {
    "***"
  }

  println("ğŸ“‹ è¨­å®š:")
  println("  Realm: \{config.realm}")
  println("  Base URL: \{config.base_url}")
  println("  Token Endpoint: \{config.token_endpoint}")
  println("  UserInfo Endpoint: \{config.userinfo_endpoint}")
  println("  Client ID: \{config.client_id}")
  println("  Client Secret: \{secret_preview}")
  println("  Test User: \{config.test_username}")
  println("")

  // å„ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œ
  test_id_token_acquisition(config)
  test_userinfo_endpoint(config)
  test_nonce_parameter(config)
  test_token_response_helpers(config)

  // ã‚µãƒãƒªãƒ¼
  print_test_separator("ãƒ†ã‚¹ãƒˆå®Œäº†")
  println("")
  println(
    "âœ“ MoonBit OIDC å®Ÿè£…ã§ Keycloak ã®å‹•ä½œã‚’æ¤œè¨¼ã—ã¾ã—ãŸ",
  )
  println("")
  println(
    "ğŸ“– è©³ç´°ãªæ‰‹é †ã¯ docs/verification/oidc_verification_guide.md ã‚’å‚ç…§",
  )
  println("")
}
